# Cursor Rules for pywiim

## FIRST: Read This File

**ALWAYS check this rules file FIRST before doing anything.** This file contains critical information about:
- Project structure (where files go)
- Environment setup (how to run code)
- Testing procedures (how to test)
- Design patterns (how to implement)

## Core Principles

1. **Check the rules file first** - Read this file before implementing, testing, or creating anything.

2. **Follow the design guide** - Always check `docs/design/` for design patterns and API standards before implementing anything.

3. **Follow the API standard** - Implement according to the documented API patterns, not made-up solutions.

4. **Do as asked** - Implement exactly what the user requests, nothing more, nothing less.

5. **Ask if uncertain** - If you don't know what to do or are uncertain about the approach, ASK THE USER before implementing anything.

6. **No made-up solutions** - Do not invent complex logic or "solutions" that aren't explicitly requested. Stick to the design guide and API standards.

7. **Stop and ask when things get complicated** - If something isn't working, doesn't make sense, or seems to require increasingly complex workarounds:
   - **STOP** - Do not continue hacking together fixes
   - **Do NOT create new files** as workarounds or "extra documentation"
   - **Do NOT pile on hack after hack** to make broken code work
   - **Instead**: Step back, review the design patterns, identify what's actually wrong, and ASK THE USER how to proceed
   - If you find yourself writing convoluted logic or creating workaround files, that's a signal to stop and ask
   - A simple question is always better than a complex hack
   - **First check**: "How does similar working code handle this?" (See "Before Adding Special Cases" section)

## When Implementing

- Check the design guide first (`docs/design/API_DESIGN_PATTERNS.md` and related files)
- Follow existing patterns in the codebase
- If the design guide says "do X", do X - don't add extra complexity
- If you're not sure, ask the user

## Documentation Maintenance - CRITICAL

**⚠️ MANDATORY: When ANY API changes are made, documentation MUST be updated immediately.**

This includes:
- Adding new properties, methods, or capabilities to the Player class
- Changing method signatures or return types
- Adding new capability properties (`supports_*`)
- Modifying existing behavior that affects how integrations use the API
- Adding new device capabilities or detection logic

**Required documentation files to update:**

1. **`docs/integration/API_REFERENCE.md`** - MUST be updated when:
   - New properties are added to Player class
   - New methods are added
   - New capabilities are added
   - Method signatures change
   - Behavior changes that affect usage

2. **`docs/integration/HA_CAPABILITIES.md`** - MUST be updated when:
   - New capability properties are added (`supports_*`)
   - Capability detection logic changes
   - New capability categories are added

3. **`docs/integration/HA_INTEGRATION.md`** - MUST be updated when:
   - Integration patterns change
   - New features require integration changes
   - Best practices change

**How to verify documentation is complete:**

1. **After adding a new property/method/capability:**
   - Search for the property/method name in the documentation files
   - Verify it's documented with description, type, and usage notes
   - Check that examples are updated if needed

2. **After modifying existing API:**
   - Verify the documentation reflects the current behavior
   - Update any outdated examples or descriptions
   - Check that breaking changes are clearly noted

3. **Before committing:**
   - Review all changes to `pywiim/player/` and `pywiim/capabilities.py`
   - Verify corresponding documentation updates exist
   - If documentation is missing, **STOP and update it before committing**

**This is non-negotiable.** Outdated documentation causes confusion, wasted time, and integration bugs. Documentation drift is a serious issue that must be prevented.

## Before Adding Special Cases or Fixes

**CRITICAL: Always check existing patterns first before adding special cases or fixes.**

1. **Question the problem statement** - Don't assume the problem description is correct
   - If an issue says "X doesn't work", verify: "Is X using the wrong method/endpoint?"
   - Check: "Are we using the same pattern that works elsewhere?"
   - Example: If masters use capability-driven endpoints, slaves should too

2. **Check how similar code paths handle it** - Look at existing working code
   - Find similar functionality that works correctly
   - Use the same pattern - don't invent a different approach
   - Example: If masters use `get_player_status()` (capability-driven), check if slaves should too

3. **Use capabilities consistently** - Capabilities are determined at device init
   - If one code path uses capability-configured endpoints, similar paths should too
   - Don't hard-code endpoints when capabilities already provide the right one
   - Don't add device-specific checks - capabilities handle device differences

4. **Don't add flags or special cases without checking** - Ask first:
   - "Does the existing pattern already handle this?"
   - "Why is this code path different from the working one?"
   - "Can we use the same capability-driven approach?"

5. **If you find yourself adding**:
   - Device model checks → STOP: Use capabilities instead
   - Endpoint string comparisons → STOP: Capabilities already provide the endpoint
   - Special flags for device types → STOP: Check if capabilities already handle it
   - Different logic for similar code paths → STOP: Make them consistent first

## Role Detection

- Follow the design guide: `docs/design/API_DESIGN_PATTERNS.md` section "Group Role Logic"
- Use `get_device_group_info()` which follows: getStatus → check slave → getSlaveList
- Do not add stability tracking, debouncing, or other complex logic unless explicitly requested

## Environment Setup

- **ALWAYS activate the Python virtual environment first**: `source .venv/bin/activate`
- The project uses `.venv` for Python dependencies
- When running Python scripts, use the venv: `source .venv/bin/activate && python3 script.py`

## Network/API Testing

- **HTTPS is the default** - devices use HTTPS, not HTTP
- When using curl, either:
  - Use `--insecure` or `-k` to disable certificate checking: `curl -k https://...`
  - Or use proper certificate handling
- When testing with Python/pywiim, the library handles HTTPS automatically
- Remember: We've tested this many times - use HTTPS by default

## Testing Against Real Devices

- **If unsure about device or API behavior, ask to test against real-world devices**
  - Don't assume behavior based on documentation or code alone
  - Real devices may behave differently than expected
  - When uncertain about how a device or API endpoint behaves, request testing against actual hardware
  - This ensures accurate implementation and prevents incorrect assumptions

## File Organization

- **Test files go in `tests/` directory** - Never put test files in the root directory
- **Scripts go in `scripts/` directory** - Check existing structure before creating files
- **Check project structure** - Look at existing files to understand where things belong
- **Don't create files in root** - Unless explicitly requested, files belong in appropriate subdirectories

## Player vs Client Methods

- **Player code MUST use player-level methods, not client methods directly**
  - Player code (in `pywiim/player/`) should call `player.get_audio_output_status()`, not `player.client.get_audio_output_status()`
  - Player-level methods automatically update the player's internal cache
  - Client methods are low-level and do NOT update the cache
  - **Exception**: The player method implementation itself (e.g., `player.audio.get_audio_output_status()`) may call client methods as part of its implementation
  - **Exception**: Scripts, CLI tools, and test code may call client methods directly when appropriate
  - **Why**: This ensures the player's cached state stays synchronized and properties work correctly

## Date Format Rules

- **CRITICAL: Always Use Actual Dates**
  - When updating CHANGELOG.md or any date fields, **ALWAYS use the actual current date** in YYYY-MM-DD format
  - **NEVER use placeholder dates** like "2025-01-XX", "2025-XX-XX", "2025-XX-13", or any date with "XX" or placeholders
  - **How to get the correct date:** Use `date +%Y-%m-%d` and use the EXACT output from this command
  - **Check existing format:** Look at previous changelog entries - format is always: `## [VERSION] - YYYY-MM-DD` (e.g., `## [1.0.7] - 2025-11-13`)
  - **If unsure, check the system date first:** Run `date +%Y-%m-%d`
  - **Why this matters:** Placeholder dates look unprofessional, require manual fixes, break automation, and confuse users reading the changelog
  - **Remember: NO PLACEHOLDERS. EVER. ALWAYS USE THE ACTUAL DATE.**

