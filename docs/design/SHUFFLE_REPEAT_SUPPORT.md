# Shuffle and Repeat Support

## Overview

Shuffle and repeat control support varies by source and content type on LinkPlay/WiiM devices. This document explains the current state, known issues, and how to test and improve support.

## Historical Issues

Shuffle and repeat support has been problematic, with multiple fixes over time:

### v2.1.2 (November 2025) - Issue #111
**Problem**: Critical misinterpretation of `loop_mode` values
- WiiM and Arylic devices use different loop_mode schemes
- WiiM: 0=loop_all, 1=repeat_one, 2=shuffle_loop, 3=shuffle_no_loop, 4=normal
- Arylic: 0=repeat_all, 1=repeat_one, 2=shuffle_repeat_all, 3=shuffle, 4=normal, 5=shuffle_repeat_one
- pywiim was treating loop_mode as bitfields, incorrectly flagging loop_mode=3 as invalid
- This broke shuffle buttons in Home Assistant

**Solution**: Added vendor-specific loop mode mappings in `pywiim/api/loop_mode.py`

### v2.1.1 (November 2025)
**Problem**: Restrictive whitelist approach blocked too many sources
- Many streaming services that should work were blocked

**Solution**: Changed to blacklist approach (permissive by default)
- Most sources now supported by default
- Only explicitly blacklist sources known not to work

### v1.0.71 (January 2025)
**Problem**: Sources where external apps control playback returning stale values
- AirPlay, Bluetooth, streaming services control shuffle/repeat from their apps
- Device returning stale cached values was misleading

**Solution**: Added source-aware shuffle/repeat control
- Return `None` for sources where device doesn't control playback
- Added `shuffle_supported` and `repeat_supported` properties

## Current Implementation

### Blacklist Approach

File: `pywiim/player/properties.py`

```python
def _is_device_controlled_source(self) -> bool:
    """Check if current source allows device-controlled playback.
    
    Uses a blacklist approach: most sources support device control,
    but some external sources don't.
    """
    source = self.source
    if source is None:
        return False
    
    source_lower = source.lower()
    
    # Blacklist: Sources where device CANNOT control shuffle/repeat
    external_controlled = {
        # Note: AirPlay was blacklisted but re-enabled for testing
        # after loop_mode fix. Testing needed to confirm.
        "tunein",       # Radio streams - no shuffle/repeat
        "iheartradio",  # Radio streams - no shuffle/repeat
        "multiroom",    # Slave device - can't control playback
    }
    
    if source_lower in external_controlled:
        return False
    
    # Radio-like sources typically don't support controls
    radio_keywords = ["radio", "stream"]
    if any(keyword in source_lower for keyword in radio_keywords):
        return False
    
    return True
```

### Properties

```python
# Check if controls are supported
if player.shuffle_supported:
    # Can control shuffle on this source
    await player.set_shuffle(True)
    state = player.shuffle_state  # bool
else:
    # Cannot control - external app controls it
    state = player.shuffle_state  # None

if player.repeat_supported:
    # Can control repeat on this source
    await player.set_repeat("all")
    mode = player.repeat_mode  # "off" | "one" | "all"
else:
    # Cannot control - external app controls it
    mode = player.repeat_mode  # None
```

## The Content Type Problem

**Key Insight**: The source alone doesn't determine support. Content type matters!

### Examples

#### Spotify
- ‚úÖ **Album playback**: On-demand content, queue-based ‚Üí Should support shuffle/repeat
- ‚ùå **Radio/Mix**: Algorithmic streaming, not queue-based ‚Üí May NOT support controls
- **Why**: Spotify Radio is generated by Spotify's algorithm, not a fixed queue

#### Amazon Music
- ‚úÖ **Album playback**: User's queue ‚Üí Should support controls
- ‚ùå **Station**: Algorithm-generated ‚Üí May NOT support controls

#### TuneIn
- ‚ùå **Live radio**: Streaming broadcast ‚Üí No shuffle/repeat
- ‚úÖ? **Podcast**: On-demand, episode list ‚Üí Might support controls

#### Apple Music (via AirPlay)
- ‚ùå **All content**: iOS device controls playback, not the WiiM device
- **Why**: AirPlay makes the WiiM a "passive sink" - iOS owns the queue

### Why Content Type Matters

LinkPlay/WiiM devices operate as a "Split Brain" system where control authority shifts based on:

1. **Transport Protocol**: How content is delivered (AirPlay, Spotify Connect, HTTP, etc.)
2. **Queue Ownership**: Who manages the playback queue (device, app, algorithm)
3. **Content Structure**: Fixed list vs algorithmic stream

The `setPlayerCmd:loopmode` endpoint only works when:
- Device is the control point (owns the queue)
- Content is queue-based (not algorithmic streaming)
- Protocol allows device-side control

## Testing Strategy

To identify what actually works, we need **empirical testing** with real devices and content.

### Test Script

```bash
source .venv/bin/activate
python scripts/test-shuffle-repeat-by-source.py <device_ip>
```

See test script: `scripts/test-shuffle-repeat-by-source.py`

### What to Test

For each streaming service, test multiple content types:

| Service | Content Type | Example | Expected |
|---------|-------------|---------|----------|
| Spotify | Album | "Rumors by Fleetwood Mac" | ‚úÖ Should work |
| Spotify | Radio | "Daily Mix 1" | ‚ùì Unknown |
| Spotify | Playlist | "Liked Songs" | ‚úÖ Should work |
| Amazon Music | Album | "1989" | ‚úÖ Should work |
| Amazon Music | Station | "Pop Hits Station" | ‚ùì Unknown |
| TuneIn | Live Radio | "BBC Radio 1" | ‚ùå Won't work |
| TuneIn | Podcast | "The Daily" | ‚ùì Unknown |
| USB | Folder | Local files | ‚úÖ Should work |
| Line In | Physical | CD Player | ‚úÖ Should work |
| AirPlay | Album | Apple Music | ‚ùå Won't work |

### What the Tests Do

1. **Predict**: Check what the library thinks (shuffle_supported, repeat_supported)
2. **Test**: Actually try the controls on real hardware
3. **Compare**: Did reality match prediction?
4. **Record**: Save detailed results including loop_mode values

### Expected Patterns

#### Will Work
- USB, SD card (local files)
- Physical inputs (Line In, Optical, Coax)
- HTTP streaming (direct URLs)
- On-demand content with device-owned queues

#### Won't Work
- Live radio streams (no queue to shuffle)
- AirPlay (iOS controls it)
- Bluetooth as sink (source device controls it)
- Algorithmic radio (no fixed queue)

#### Needs Testing
- Spotify albums vs radio
- Amazon Music albums vs stations
- Tidal, Qobuz, Deezer
- DLNA sources
- Podcasts

## Known Blacklisted Sources

Current blacklist (as of v2.1.2):

### Confirmed Non-Working
- `tunein` - Live radio streams
- `iheartradio` - Live radio streams  
- `multiroom` - Slave devices (can't control master's playback)
- Sources with "radio" or "stream" in name

### Previously Blacklisted, Now Re-enabled for Testing
- `airplay` - May work after loop_mode fix, needs testing

### Never Blacklisted (Permissive Approach)
- `spotify` - Needs content-type-aware testing
- `amazon` - Needs content-type-aware testing
- `tidal`, `qobuz`, `deezer` - Assumed to work, needs testing
- `bluetooth` - Assumed to work when device is controller
- `dlna` - Assumed to work, needs testing
- Physical inputs - Should always work

## Integration Guidelines

### Home Assistant

```python
class WiiMMediaPlayer(MediaPlayerEntity):
    @property
    def supported_features(self):
        """Return flag of media commands supported."""
        features = (
            MediaPlayerEntityFeature.VOLUME_SET
            | MediaPlayerEntityFeature.VOLUME_MUTE
            | MediaPlayerEntityFeature.PLAY
            | MediaPlayerEntityFeature.PAUSE
            | MediaPlayerEntityFeature.NEXT_TRACK
            | MediaPlayerEntityFeature.PREVIOUS_TRACK
        )
        
        # Only show shuffle/repeat if supported for current source
        if self._player.shuffle_supported:
            features |= MediaPlayerEntityFeature.SHUFFLE_SET
        
        if self._player.repeat_supported:
            features |= MediaPlayerEntityFeature.REPEAT_SET
        
        return features
    
    @property
    def shuffle(self):
        """Return shuffle state."""
        # Returns None when not supported, hiding control
        return self._player.shuffle_state
    
    @property
    def repeat(self):
        """Return repeat mode."""
        # Returns None when not supported, hiding control
        mode = self._player.repeat_mode
        if mode == "one":
            return RepeatMode.ONE
        elif mode == "all":
            return RepeatMode.ALL
        else:
            return RepeatMode.OFF
```

### Best Practices

1. **Check support first**: Use `shuffle_supported` / `repeat_supported`
2. **Hide unavailable controls**: Don't show shuffle button if not supported
3. **Handle None gracefully**: Properties return `None` when not supported
4. **Don't cache support**: Check on each state update (source can change)

## Future Improvements

### Content-Type-Aware Support

May need to add content-type detection:

```python
def _is_device_controlled_source(self) -> bool:
    """Check if source allows device-controlled playback."""
    source = self.source
    if source is None:
        return False
    
    source_lower = source.lower()
    
    # Existing blacklist checks...
    
    # Content-type-aware logic (future)
    if source_lower == "spotify":
        # Check if it's radio/mix vs album/playlist
        # May need additional API calls or metadata checks
        return self._is_spotify_on_demand_content()
    
    return True
```

### API Enhancements

Consider adding:
- `content_type` property (album, radio, live, etc.)
- More granular capability detection
- Spotify API integration to detect content type

### Documentation

After systematic testing:
1. Update blacklist based on empirical results
2. Document content-type-specific behavior
3. Add known exceptions and workarounds
4. Update integration guides with findings

## References

- CHANGELOG entries: v2.1.2, v2.1.1, v1.0.71
- GitHub Issue #111: Shuffle/repeat broken
- Design doc: `docs/design/API_DESIGN_PATTERNS.md`
- Test script: `scripts/test-shuffle-repeat-by-source.py`
- Test script: `scripts/test-shuffle-repeat-by-source.py`
- LinkPlay architecture: CHANGELOG v1.0.71 technical background

## Summary

Shuffle and repeat support is **complex** because:

1. **Multiple vendors** (WiiM, Arylic) use different loop_mode schemes
2. **Control authority** varies by transport protocol
3. **Content type** affects whether controls work
4. **Source alone** isn't enough to predict support

The solution is **empirical testing** across sources and content types to build accurate predictions. The test script and guide help systematically collect this data.

**Goal**: Finally nail down shuffle/repeat support with real-world testing! üéØ

